<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Asteroid Shooter</title>

    <!-- use external stylesheet only (cleaner, single source of truth) -->
    <link rel="stylesheet" href="Space_Shooter.css" />
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" aria-label="Game canvas" role="img"></canvas>

        <div id="ui-container" aria-hidden="false">
            <div id="score" aria-live="polite">Score: 0</div>
            <div id="lives" aria-live="polite">Lives: 3</div>
        </div>

        <div id="game-over" role="dialog" aria-modal="true" aria-labelledby="gameover-title" aria-hidden="true">
            <h1 id="gameover-title">Game Over</h1>
            <p id="final-score">Your Score: 0</p>
            <button id="restart-button">Restart Game</button>
        </div>

        <div class="touch-controls" aria-hidden="true">
            <div id="touch-left" class="touch-button" aria-hidden="true">◀</div>
            <div id="touch-fire" class="touch-button" aria-hidden="true">●</div>
            <div id="touch-right" class="touch-button" aria-hidden="true">▶</div>
        </div>
    </div>

    <script>
    // compactible, robust JS — safe improvements only
    (function () {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // helpers - CSS pixels (ctx is transformed for DPR)
        const W = ()=> canvas.clientWidth;
        const H = ()=> canvas.clientHeight;

        // Limits to avoid runaway memory / DOS-like growth
        const MAX_BULLETS = 60;
        const MAX_ENEMIES = 20;
        const MAX_ASTEROIDS = 80;
        const MAX_PARTICLES = 400;

        // State
        let ship, bullets, asteroids, enemies, enemyBullets, particlePool;
        let score = 0, lives = 3, gameOver = false;
        let keys = {};
        let asteroidTimerId = null;
        let enemyTimerId = null;
        let animationId = null;

        // DPI-aware resize
        function resizeCanvas(){
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));

            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            // allocate pixel buffer according to DPR
            canvas.width = Math.max(1, Math.floor(rect.width * dpr));
            canvas.height = Math.max(1, Math.floor(rect.height * dpr));

            // draw in CSS pixels by scaling context
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // keep ship inside bounds if exists
            if (ship) {
                ship.x = Math.min(Math.max(ship.x, ship.radius), W() - ship.radius);
                ship.y = Math.min(Math.max(ship.y, ship.radius), H() - ship.radius);
            }
        }

        // Entities
        class Ship {
            constructor() {
                this.radius = 20;
                this.speed = 7;
                this.color = '#adeee3';
                this.gunCooldown = 12;
                this.gunTimer = 0;
                this.x = W() / 2;
                this.y = H() - 50;
            }
            draw(){
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.radius);
                ctx.lineTo(this.x - this.radius, this.y + this.radius);
                ctx.lineTo(this.x + this.radius, this.y + this.radius);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();

                // subtle thruster flicker
                if (keys['ArrowLeft'] || keys['ArrowRight'] || Math.random() < 0.18) {
                    ctx.beginPath();
                    ctx.moveTo(this.x - 8, this.y + this.radius);
                    ctx.lineTo(this.x + 8, this.y + this.radius);
                    ctx.lineTo(this.x, this.y + this.radius + 10 + Math.random() * 5);
                    ctx.closePath();
                    ctx.fillStyle = '#f9a620';
                    ctx.fill();
                }
            }
            update(){
                if (keys['ArrowLeft'] && this.x - this.radius > 0) this.x -= this.speed;
                if (keys['ArrowRight'] && this.x + this.radius < W()) this.x += this.speed;
                if (keys['Space']) this.shoot();
                if (this.gunTimer > 0) this.gunTimer--;
                this.draw();
            }
            shoot(){
                if (this.gunTimer === 0 && bullets.length < MAX_BULLETS) {
                    bullets.push(new Bullet(this.x, this.y - this.radius));
                    this.gunTimer = this.gunCooldown;
                }
            }
        }

        class Bullet {
            constructor(x,y){
                this.x = x; this.y = y;
                this.radius = 4; this.speed = 10; this.color = '#7fdbff';
            }
            draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); }
            update(){ this.y -= this.speed; this.draw(); }
        }

        class EnemyBullet {
            constructor(x,y){ this.x=x; this.y=y; this.radius=5; this.speed=5; this.color='#ff4136'; }
            draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); }
            update(){ this.y += this.speed; this.draw(); }
        }

        class Enemy {
            constructor(){
                this.x = Math.random() * W();
                this.y = -30;
                this.radius = 20;
                this.speed = 2;
                this.color = '#ff851b';
                this.gunCooldown = 100;
                this.gunTimer = Math.floor(Math.random() * this.gunCooldown);
            }
            draw(){
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + this.radius);
                ctx.lineTo(this.x - this.radius, this.y - this.radius);
                ctx.lineTo(this.x + this.radius, this.y - this.radius);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            update(){
                this.y += this.speed;
                if (this.gunTimer <= 0){ this.shoot(); this.gunTimer = this.gunCooldown; } else this.gunTimer--;
                this.draw();
            }
            shoot(){ if (enemyBullets.length < MAX_BULLETS) enemyBullets.push(new EnemyBullet(this.x, this.y)); }
        }

        class Asteroid {
            constructor(x,y,radius,dx,dy){
                this.x = (typeof x === 'number') ? x : Math.random() * W();
                this.y = (typeof y === 'number') ? y : - (radius || (15 + Math.random()*30));
                this.radius = radius || 15 + Math.random() * 30;
                this.speed = {
                    x: dx || (Math.random() - 0.5) * 3,
                    y: dy || 1 + Math.random() * 2
                };
                this.color = '#f0f0f0';
                this.vertices = [];
                const vertCount = 7 + Math.floor(Math.random()*5);
                for (let i=0;i<vertCount;i++){
                    const angle = (i/vertCount) * Math.PI * 2;
                    const radiusOffset = this.radius * (0.75 + Math.random()*0.5);
                    this.vertices.push({ x: Math.cos(angle)*radiusOffset, y: Math.sin(angle)*radiusOffset });
                }
            }
            draw(){
                ctx.beginPath();
                ctx.moveTo(this.x + this.vertices[0].x, this.y + this.vertices[0].y);
                for (let i=1;i<this.vertices.length;i++){
                    ctx.lineTo(this.x + this.vertices[i].x, this.y + this.vertices[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            update(){
                this.x += this.speed.x;
                this.y += this.speed.y;
                this.draw();
            }
        }

        class Particle {
            constructor(x,y,color){
                this.x=x; this.y=y; this.color=color;
                this.radius = Math.random()*3 + 1;
                this.speed = { x:(Math.random()-0.5)*5, y:(Math.random()-0.5)*5 };
                this.lifespan = 60;
            }
            draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); }
            update(){ this.x += this.speed.x; this.y += this.speed.y; this.lifespan--; this.draw(); }
        }

        function createExplosion(x,y,color){
            const amount = 18;
            for (let i=0;i<amount;i++){
                if (particlePool.length < MAX_PARTICLES) particlePool.push(new Particle(x,y,color));
            }
        }

        // Input handling (use event.code consistently)
        window.addEventListener('keydown', (e) => {
            const key = e.code || e.key;
            if (key === 'Space' || key === 'ArrowLeft' || key === 'ArrowRight') e.preventDefault();
            keys[key] = true;
        }, {passive:false});

        window.addEventListener('keyup', (e) => {
            const key = e.code || e.key;
            keys[key] = false;
        });

        // Touch / pointer helpers — setPointerCapture to avoid missed pointerup
        function addTouchControl(id, keyName){
            const el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('pointerdown', (ev) => {
                ev.preventDefault();
                try { ev.target.setPointerCapture(ev.pointerId); } catch (err) {}
                keys[keyName] = true;
            }, {passive:false});
            el.addEventListener('pointerup', (ev) => {
                ev.preventDefault();
                try { ev.target.releasePointerCapture && ev.target.releasePointerCapture(ev.pointerId); } catch (err) {}
                keys[keyName] = false;
            });
            el.addEventListener('pointercancel', ()=> keys[keyName]=false);
            el.addEventListener('pointerleave', ()=> keys[keyName]=false);
            // legacy touch fallback
            el.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); keys[keyName]=true; }, {passive:false});
            el.addEventListener('touchend', ()=> keys[keyName]=false);
        }
        addTouchControl('touch-left','ArrowLeft');
        addTouchControl('touch-right','ArrowRight');
        addTouchControl('touch-fire','Space');

        // Defensive: clear controls when pointer ends anywhere (prevents stuck keys)
        window.addEventListener('pointerup', ()=> { keys['ArrowLeft']=false; keys['ArrowRight']=false; keys['Space']=false; });
        window.addEventListener('touchend', ()=> { keys['ArrowLeft']=false; keys['ArrowRight']=false; keys['Space']=false; });

        // Pause/resume on visibility
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('visibilitychange', ()=>{ if (document.hidden) pauseGame(); else resumeGame(); });
        window.addEventListener('blur', pauseGame);
        window.addEventListener('focus', resumeGame);

        function pauseGame(){
            if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        }
        function resumeGame(){
            if (!gameOver && !animationId) animationId = requestAnimationFrame(loop);
        }

        function clearSpawnTimers(){
            if (asteroidTimerId) { clearTimeout(asteroidTimerId); asteroidTimerId = null; }
            if (enemyTimerId) { clearTimeout(enemyTimerId); enemyTimerId = null; }
        }

        function spawnAsteroids(){
            if (gameOver) return;
            const count = Math.min(MAX_ASTEROIDS - asteroids.length, Math.floor(score / 500) + 1);
            for (let i=0;i<count;i++) asteroids.push(new Asteroid());
            const delay = Math.max(700, 3000 - score / 10);
            clearTimeout(asteroidTimerId);
            asteroidTimerId = setTimeout(spawnAsteroids, delay);
        }

        function spawnEnemies(){
            if (gameOver) return;
            const count = Math.min(MAX_ENEMIES - enemies.length, Math.floor(score / 1000) + 1);
            for (let i=0;i<count;i++) enemies.push(new Enemy());
            const delay = Math.max(1500, 8000 - score / 10);
            clearTimeout(enemyTimerId);
            enemyTimerId = setTimeout(spawnEnemies, delay);
        }

        function updateUI(){
            const s = document.getElementById('score');
            const l = document.getElementById('lives');
            if (s) s.textContent = `Score: ${score}`;
            if (l) l.textContent = `Lives: ${lives}`;
        }

        function checkCollisions(){
            // bullets <-> asteroids
            for (let i=bullets.length-1;i>=0;i--){
                const b = bullets[i];
                for (let j=asteroids.length-1;j>=0;j--){
                    const a = asteroids[j];
                    if (!b || !a) continue;
                    const dist = Math.hypot(b.x - a.x, b.y - a.y);
                    if (dist < a.radius + b.radius){
                        createExplosion(a.x, a.y, a.color);
                        score += Math.max(10, Math.floor(50 - a.radius));
                        if (a.radius > 20) {
                            const newRadius = a.radius / 2;
                            asteroids.push(new Asteroid(a.x, a.y, newRadius, a.speed.x + Math.random() - 0.5, a.speed.y + Math.random() - 0.5));
                            asteroids.push(new Asteroid(a.x, a.y, newRadius, -a.speed.x + Math.random() - 0.5, a.speed.y + Math.random() - 0.5));
                        }
                        asteroids.splice(j,1);
                        bullets.splice(i,1);
                        updateUI();
                        break;
                    }
                }
            }

            // bullets <-> enemies
            for (let i=bullets.length-1;i>=0;i--){
                const b = bullets[i];
                for (let j=enemies.length-1;j>=0;j--){
                    const en = enemies[j];
                    if (!b || !en) continue;
                    const dist = Math.hypot(b.x - en.x, b.y - en.y);
                    if (dist < en.radius + b.radius){
                        createExplosion(en.x, en.y, en.color);
                        score += 150;
                        enemies.splice(j,1);
                        bullets.splice(i,1);
                        updateUI();
                        break;
                    }
                }
            }

            // ship collisions
            for (let i=asteroids.length-1;i>=0;i--){
                const a = asteroids[i];
                const dist = Math.hypot(ship.x - a.x, ship.y - a.y);
                if (dist < a.radius + ship.radius){
                    createExplosion(ship.x, ship.y, ship.color);
                    createExplosion(a.x, a.y, a.color);
                    asteroids.splice(i,1);
                    lives--;
                    updateUI();
                    if (lives <= 0) { endGame(); return; }
                    ship.x = W()/2; ship.y = H() - 50;
                }
            }

            for (let i=enemies.length-1;i>=0;i--){
                const en = enemies[i];
                const dist = Math.hypot(ship.x - en.x, ship.y - en.y);
                if (dist < en.radius + ship.radius){
                    createExplosion(ship.x, ship.y, ship.color);
                    createExplosion(en.x, en.y, en.color);
                    enemies.splice(i,1);
                    lives--;
                    updateUI();
                    if (lives <= 0) { endGame(); return; }
                    ship.x = W()/2; ship.y = H() - 50;
                }
            }

            for (let i=enemyBullets.length-1;i>=0;i--){
                const eb = enemyBullets[i];
                const dist = Math.hypot(ship.x - eb.x, ship.y - eb.y);
                if (dist < eb.radius + ship.radius){
                    createExplosion(ship.x, ship.y, ship.color);
                    enemyBullets.splice(i,1);
                    lives--;
                    updateUI();
                    if (lives <= 0) { endGame(); return; }
                    ship.x = W()/2; ship.y = H() - 50;
                }
            }
        }

        function endGame(){
            gameOver = true;
            clearSpawnTimers();
            if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
            document.getElementById('final-score').textContent = `Your Score: ${score}`;
            const dialog = document.getElementById('game-over');
            dialog.style.display = 'flex';
            dialog.setAttribute('aria-hidden', 'false');
            // move focus to restart button for accessibility
            const btn = document.getElementById('restart-button');
            if (btn) btn.focus();
        }

        function loop(){
            if (gameOver) {
                if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
                return;
            }

            ctx.clearRect(0,0,W(),H());

            ship.update();

            // bullets
            for (let i=bullets.length-1;i>=0;i--){
                bullets[i].update();
                if (bullets[i].y < -50) bullets.splice(i,1);
            }

            // enemies
            for (let i=enemies.length-1;i>=0;i--){
                enemies[i].update();
                if (enemies[i].y - enemies[i].radius > H()) enemies.splice(i,1);
            }

            // enemy bullets
            for (let i=enemyBullets.length-1;i>=0;i--){
                enemyBullets[i].update();
                if (enemyBullets[i].y - enemyBullets[i].radius > H()) enemyBullets.splice(i,1);
            }

            // asteroids
            for (let i=asteroids.length-1;i>=0;i--){
                asteroids[i].update();
                if (asteroids[i].y - asteroids[i].radius > H() ||
                    asteroids[i].x + asteroids[i].radius < 0 ||
                    asteroids[i].x - asteroids[i].radius > W()) {
                    asteroids.splice(i,1);
                }
            }

            // particles
            for (let i=particlePool.length-1;i>=0;i--){
                particlePool[i].update();
                if (particlePool[i].lifespan <= 0) particlePool.splice(i,1);
            }

            checkCollisions();
            animationId = requestAnimationFrame(loop);
        }

        // Init and restart — create ship before starting loop to avoid race
        function init(){
            resizeCanvas();

            bullets = []; asteroids = []; enemies = []; enemyBullets = []; particlePool = [];
            score = 0; lives = 3; gameOver = false;
            updateUI();
            clearSpawnTimers();

            // create player before starting animation
            ship = new Ship();

            // start spawns
            spawnAsteroids();
            spawnEnemies();

            const dialog = document.getElementById('game-over');
            if (dialog) { dialog.style.display = 'none'; dialog.setAttribute('aria-hidden','true'); }

            if (!animationId) animationId = requestAnimationFrame(loop);
        }

        // restart button (attach once)
        const restartBtn = document.getElementById('restart-button');
        if (restartBtn) {
            restartBtn.addEventListener('click', (e)=> { e.preventDefault(); init(); });
            restartBtn.addEventListener('keydown', (e)=> {
                if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); init(); }
            });
        }

        // initial setup
        resizeCanvas();
        init();

        // defensive unload cleanup
        window.addEventListener('beforeunload', () => {
            clearSpawnTimers();
            if (animationId) cancelAnimationFrame(animationId);
        });

    })();
    </script>
</body>
</html>
